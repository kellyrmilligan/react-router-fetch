{"version":3,"sources":["../src/__tests__/react-router-fetch.js"],"names":["describe","it","expect","toBeTruthy","done","then","handler","fetch","Promise","resolve","reject","setTimeout","test","handler2","props","components","params","location","query","spyOn","and","callThrough","response","toHaveBeenCalled","promises","length","toBe"],"mappings":";;AAEA;;;;;;AAEAA,SAAS,gBAAT,EAA2B,YAAY;AACrCC,KAAG,iBAAH,EAAsB,YAAY;AAChCC,4BAAsBC,UAAtB;AACD,GAFD;AAGAF,KAAG,8CAAH,EAAmD,UAAUG,IAAV,EAAgB;AACjE,yBAAc,EAAd,EAAkB,IAAlB,EACGC,IADH,CACQ,YAAM;AACVD;AACD,KAHH;AAID,GALD;AAMAH,KAAG,kDAAH,EAAuD,UAAUG,IAAV,EAAgB;AACrE,QAAME,UAAU;AACdC,WADc,mBACL;AACP,eAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtCC,qBAAWF,OAAX,EAAoB,IAApB,EAA0B,EAAEG,MAAM,MAAR,EAA1B;AACD,SAFM,CAAP;AAGD;AALa,KAAhB;AAOA,QAAMC,WAAW;AACfN,WADe,mBACN;AACP,eAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtCC,qBAAWF,OAAX,EAAoB,IAApB,EAA0B,EAAEG,MAAM,MAAR,EAA1B;AACD,SAFM,CAAP;AAGD;AALc,KAAjB;AAOA,QAAME,QAAQ;AACZC,kBAAY,CACVT,OADU,EAEVO,QAFU,CADA;AAKZG,cAAQ,EALI;AAMZC,gBAAU;AACRC,eAAO;AADC;AANE,KAAd;AAUAC,UAAMb,OAAN,EAAe,OAAf,EAAwBc,GAAxB,CAA4BC,WAA5B;AACA,yBAAcP,KAAd,EACGT,IADH,CACQ,UAACiB,QAAD,EAAc;AAClBpB,aAAOI,QAAQC,KAAf,EAAsBgB,gBAAtB;AACAnB;AACD,KAJH;AAKD,GA/BD;AAgCAH,KAAG,mDAAH,EAAwD,UAAUG,IAAV,EAAgB;AACtE,QAAME,UAAU,EAAhB;AAEA,QAAMQ,QAAQ;AACZC,kBAAY,CACVT,OADU,CADA;AAIZU,cAAQ,EAJI;AAKZC,gBAAU;AACRC,eAAO;AADC;AALE,KAAd;AASA,yBAAcJ,KAAd,EACGT,IADH,CACQ,UAACmB,QAAD,EAAc;AAClBtB,aAAOsB,SAASC,MAAhB,EAAwBC,IAAxB,CAA6B,CAA7B;AACAtB;AACD,KAJH;AAKD,GAjBD;AAkBD,CA5DD,E,CAJA","file":"react-router-fetch.js","sourcesContent":["/* global describe, it, expect, spyOn */\n\nimport routeResolver from 'lib/index'\n\ndescribe('route-resolver', function () {\n  it('can be imported', function () {\n    expect(routeResolver).toBeTruthy()\n  })\n  it('will resolve right away if isInitial is true', function (done) {\n    routeResolver({}, true)\n      .then(() => {\n        done()\n      })\n  })\n  it('will call fetch on a route handler if it has one', function (done) {\n    const handler = {\n      fetch () {\n        return new Promise((resolve, reject) => {\n          setTimeout(resolve, 1000, { test: '1234' })\n        })\n      }\n    }\n    const handler2 = {\n      fetch () {\n        return new Promise((resolve, reject) => {\n          setTimeout(resolve, 1000, { test: '1234' })\n        })\n      }\n    }\n    const props = {\n      components: [\n        handler,\n        handler2\n      ],\n      params: {},\n      location: {\n        query: {}\n      }\n    }\n    spyOn(handler, 'fetch').and.callThrough()\n    routeResolver(props)\n      .then((response) => {\n        expect(handler.fetch).toHaveBeenCalled()\n        done()\n      })\n  })\n  it('will resolve right away if no handlers have fetch', function (done) {\n    const handler = {\n    }\n    const props = {\n      components: [\n        handler\n      ],\n      params: {},\n      location: {\n        query: {}\n      }\n    }\n    routeResolver(props)\n      .then((promises) => {\n        expect(promises.length).toBe(0)\n        done()\n      })\n  })\n})\n"]}